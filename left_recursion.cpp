#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>

using namespace std;

// Function to split a string based on a delimiter
vector<string> split(const string& str, char delimiter) {
    vector<string> tokens;
    stringstream ss(str);
    string token;
    while (getline(ss, token, delimiter)) {
        // Remove leading and trailing whitespaces from token
        token.erase(0, token.find_first_not_of(" \t\n\r\f\v"));
        token.erase(token.find_last_not_of(" \t\n\r\f\v") + 1);
        tokens.push_back(token);
    }
    return tokens;
}

int main() {
    int n;
    cout << "Enter the number of productions: ";
    cin >> n;
    cin.ignore();

    vector<string> nonTerminals(n);
    vector<string> productions(n);

    cout << "Enter the productions (e.g., A -> Aa | b):" << endl;
    for (int i = 0; i < n; ++i) {
        getline(cin, productions[i]);
        nonTerminals[i] = productions[i].substr(0, productions[i].find("->") - 1);
        // Remove leading and trailing whitespaces from nonTerminals
        nonTerminals[i].erase(0, nonTerminals[i].find_first_not_of(" \t\n\r\f\v"));
        nonTerminals[i].erase(nonTerminals[i].find_last_not_of(" \t\n\r\f\v") + 1);
    }

    for (int i = 0; i < n; ++i) 
    {
        string nonTerminal = nonTerminals[i];
        string production = productions[i].substr(productions[i].find("->") + 2);
        // Remove leading and trailing whitespaces from production
        production.erase(0, production.find_first_not_of(" \t\n\r\f\v"));
        production.erase(production.find_last_not_of(" \t\n\r\f\v") + 1);
        
        vector<string> rules = split(production, '|');
        vector<string> alpha, beta;

        for (string rule : rules) {
            rule.erase(0, rule.find_first_not_of(" \t\n\r\f\v")); // Trim leading spaces
            rule.erase(rule.find_last_not_of(" \t\n\r\f\v") + 1); // Trim trailing spaces
            if (rule[0] == nonTerminal[0]) {
                alpha.push_back(rule.substr(1));
            } else {
                beta.push_back(rule);
            }
        }

        if (!alpha.empty()) {
            // Print transformed grammar
            cout << nonTerminal << " -> ";
            for (size_t j = 0; j < beta.size(); ++j) {
                cout << beta[j] << nonTerminal << "' ";
                if (j != beta.size() - 1) cout << "| ";
            }
            cout << endl;

            cout << nonTerminal << "' -> ";
            for (size_t j = 0; j < alpha.size(); ++j) {
                cout << alpha[j] << nonTerminal << "' ";
                if (j != alpha.size() - 1) cout << "| ";
            }
            cout << "| ε" << endl;
        } else {
            // No left recursion
            cout << nonTerminal << " -> " << production << endl;
        }
    }

    return 0;
}



/*
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Function Purpose: [vector<string> split(const string& str, char delimiter);]

The function `split` is designed to take a string and split it into a vector of substrings based on a specified delimiter. Additionally, it trims any leading or trailing whitespace from each resulting substring (token).

### Function Signature:

```cpp
vector<string> split(const string& str, char delimiter);
```

- **`vector<string>`**: The function returns a `vector` of `string` objects, where each string is a substring of the input string `str`, split by the delimiter.
- **`const string& str`**: The function takes a reference to a constant string as input. This string is the one that will be split.
- **`char delimiter`**: The character that will be used to determine where to split the string.

### Inside the Function:

1. **Initialize the `stringstream` Object:**
   ```cpp
   stringstream ss(str);
   ```
   - `stringstream ss(str);`: This creates a `stringstream` object `ss` initialized with the input string `str`. The `stringstream` allows us to use stream-based operations on the string as if it were a stream (like `cin` or `ifstream`).

2. **Prepare for the Output:**
   ```cpp
   vector<string> tokens;
   ```
   - `vector<string> tokens;`: This creates an empty vector `tokens` that will store the substrings (tokens) generated by splitting the input string.

3. **Splitting the String:**
   ```cpp
   string token;
   while (getline(ss, token, delimiter)) {
   ```
   - `string token;`: A string variable `token` is declared to temporarily hold each substring extracted from the stream.
   - `while (getline(ss, token, delimiter))`: This loop extracts substrings from the `stringstream` `ss` one by one, using the provided `delimiter` to determine where to split. Each time `getline` is called, it reads from `ss` until it encounters the `delimiter`, and stores the result in `token`.

4. **Trimming Whitespace from Each Token:**
   ```cpp
   token.erase(0, token.find_first_not_of(" \t\n\r\f\v"));
   token.erase(token.find_last_not_of(" \t\n\r\f\v") + 1);
   ```
   - `token.erase(0, token.find_first_not_of(" \t\n\r\f\v"));`: This removes leading whitespace from `token`. `find_first_not_of(" \t\n\r\f\v")` finds the first character that is not a whitespace character. `erase(0, ...)` removes all characters from the start of the string up to this position, effectively trimming leading whitespace.
   - `token.erase(token.find_last_not_of(" \t\n\r\f\v") + 1);`: Similarly, this removes trailing whitespace. `find_last_not_of(" \t\n\r\f\v")` finds the last character that is not a whitespace character, and `erase(... + 1)` removes everything after this position, effectively trimming trailing whitespace.

5. **Storing the Token:**
   ```cpp
   tokens.push_back(token);
   ```
   - After trimming, the cleaned `token` is added to the `tokens` vector.

6. **Returning the Result:**
   ```cpp
   return tokens;
   ```
   - Once the loop has finished processing all parts of the string, the `tokens` vector, now containing all the split and trimmed substrings, is returned.

### Summary:

- **Purpose**: The function splits a string into substrings based on a delimiter and trims whitespace from each substring.
- **Key Operations**: 
  - Using `stringstream` to read tokens.
  - Using `erase` with `find_first_not_of` and `find_last_not_of` to trim whitespace.
- **Output**: A vector of clean, split substrings.
*/


/*  
------------------------------------------------------------------------------------------
Certainly! Here’s a detailed line-by-line explanation of the C++ code:

### Include Directives and Namespace

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>

using namespace std;
```

- **`#include <iostream>`**: Includes the standard I/O stream library for input and output operations.
- **`#include <vector>`**: Includes the vector container library, which provides the `std::vector` class.
- **`#include <string>`**: Includes the string library for using the `std::string` class.
- **`#include <sstream>`**: Includes the string stream library, which provides functionality to manipulate strings as streams.
- **`#include <algorithm>`**: Includes algorithms for various operations like searching and modifying elements.
- **`using namespace std;`**: Allows the code to use standard library objects and functions without needing the `std::` prefix.

### Function to Split Strings

```cpp
vector<string> split(const string& str, char delimiter) {
    vector<string> tokens;
    stringstream ss(str);
    string token;
    while (getline(ss, token, delimiter)) {
        // Remove leading and trailing whitespaces from token
        token.erase(0, token.find_first_not_of(" \t\n\r\f\v"));
        token.erase(token.find_last_not_of(" \t\n\r\f\v") + 1);
        tokens.push_back(token);
    }
    return tokens;
}
```

- **`vector<string> split(const string& str, char delimiter)`**: Defines a function that splits a string `str` into a vector of strings based on a `delimiter` character.
- **`vector<string> tokens;`**: Initializes a vector to store the resulting tokens.
- **`stringstream ss(str);`**: Creates a `stringstream` object initialized with `str`, allowing it to be used like a stream.
- **`string token;`**: A string variable to temporarily hold each token extracted from the stream.
- **`while (getline(ss, token, delimiter))`**: Reads from the `stringstream` line by line (or token by token) separated by `delimiter`, storing each token in `token`.
  - **`getline(ss, token, delimiter)`**: Extracts tokens from `ss` separated by `delimiter`.
- **`token.erase(0, token.find_first_not_of(" \t\n\r\f\v"));`**: Removes leading whitespace from `token`. 
  - **`find_first_not_of(" \t\n\r\f\v")`**: Finds the position of the first non-whitespace character.
  - **`erase(0, ...)`**: Erases characters from the beginning of `token` up to the first non-whitespace character.
- **`token.erase(token.find_last_not_of(" \t\n\r\f\v") + 1);`**: Removes trailing whitespace from `token`.
  - **`find_last_not_of(" \t\n\r\f\v")`**: Finds the position of the last non-whitespace character.
  - **`erase(..., ...)`**: Erases characters from the end of `token` after the last non-whitespace character.
- **`tokens.push_back(token);`**: Adds the cleaned `token` to the `tokens` vector.
- **`return tokens;`**: Returns the vector of tokens.

### Main Function

```cpp
int main() {
    int n;
    cout << "Enter the number of productions: ";
    cin >> n;
    cin.ignore();
```

- **`int n;`**: Declares an integer variable to store the number of productions.
- **`cout << "Enter the number of productions: ";`**: Prompts the user to input the number of productions.
- **`cin >> n;`**: Reads the number of productions from the user.
- **`cin.ignore();`**: Clears the newline character from the input buffer to ensure correct reading of subsequent lines.

```cpp
    vector<string> nonTerminals(n);
    vector<string> productions(n);
```

- **`vector<string> nonTerminals(n);`**: Initializes a vector to store non-terminal symbols for each production.
- **`vector<string> productions(n);`**: Initializes a vector to store the production rules as strings.

```cpp
    cout << "Enter the productions (e.g., A -> Aa | b):" << endl;
    for (int i = 0; i < n; ++i) {
        getline(cin, productions[i]);
        nonTerminals[i] = productions[i].substr(0, productions[i].find("->") - 1);
        // Remove leading and trailing whitespaces from nonTerminals
        nonTerminals[i].erase(0, nonTerminals[i].find_first_not_of(" \t\n\r\f\v"));
        nonTerminals[i].erase(nonTerminals[i].find_last_not_of(" \t\n\r\f\v") + 1);
    }
```

- **`cout << "Enter the productions (e.g., A -> Aa | b):" << endl;`**: Prompts the user to enter the productions.
- **`for (int i = 0; i < n; ++i)`**: Loops to read `n` productions.
  - **`getline(cin, productions[i]);`**: Reads each production rule from the user.
  - **`nonTerminals[i] = productions[i].substr(0, productions[i].find("->") - 1);`**: Extracts the non-terminal part from each production.
    - **`substr(0, productions[i].find("->") - 1)`**: Gets the substring from the start up to the position before `->`.
  - **`nonTerminals[i].erase(0, nonTerminals[i].find_first_not_of(" \t\n\r\f\v"));`**: Removes leading whitespace from the non-terminal.
  - **`nonTerminals[i].erase(nonTerminals[i].find_last_not_of(" \t\n\r\f\v") + 1);`**: Removes trailing whitespace from the non-terminal.

```cpp
    for (int i = 0; i < n; ++i) {
        string nonTerminal = nonTerminals[i];
        string production = productions[i].substr(productions[i].find("->") + 2);
        // Remove leading and trailing whitespaces from production
        production.erase(0, production.find_first_not_of(" \t\n\r\f\v"));
        production.erase(production.find_last_not_of(" \t\n\r\f\v") + 1);
        
        vector<string> rules = split(production, '|');
        vector<string> alpha, beta;

        for (string rule : rules) {
            rule.erase(0, rule.find_first_not_of(" \t\n\r\f\v")); // Trim leading spaces
            rule.erase(rule.find_last_not_of(" \t\n\r\f\v") + 1); // Trim trailing spaces
            if (rule[0] == nonTerminal[0]) {
                alpha.push_back(rule.substr(1));
            } else {
                beta.push_back(rule);
            }
        }
```

- **`for (int i = 0; i < n; ++i)`**: Loops over each production to process them.
  - **`string nonTerminal = nonTerminals[i];`**: Assigns the non-terminal to a local variable.
  - **`string production = productions[i].substr(productions[i].find("->") + 2);`**: Extracts the right-hand side of the production (the part after `->`).
  - **`production.erase(0, production.find_first_not_of(" \t\n\r\f\v"));`**: Removes leading whitespace from the production.
  - **`production.erase(production.find_last_not_of(" \t\n\r\f\v") + 1);`**: Removes trailing whitespace from the production.
  - **`vector<string> rules = split(production, '|');`**: Splits the production into individual rules using `|` as the delimiter.
  - **`vector<string> alpha, beta;`**: Vectors to store the parts of the rules with and without left recursion.
  - **`for (string rule : rules)`**: Loops over each rule.
    - **`rule.erase(0, rule.find_first_not_of(" \t\n\r\f\v"));`**: Trims leading whitespace from the rule.
    - **`rule.erase(rule.find_last_not_of(" \t\n\r\f\v") + 1);`**: Trims trailing whitespace from the rule.
    - **`if (rule[0] == nonTerminal[0])`**: Checks if the rule starts with the non-terminal symbol (indicating left recursion).
      - **`alpha.push_back(rule.substr(1));`**: Adds the part of the rule after the non-terminal to `alpha`.
    - **`else`**: If the rule does not start with the non-terminal symbol:
      - **`beta.push_back(rule);`**: Adds the rule to `beta`.

```cpp
        if (!alpha.empty()) {
            // Print transformed grammar
            cout << nonTerminal << " -> ";
            for (size_t j = 0; j < beta.size(); ++j) {
                cout << beta[j] << nonTerminal << "' ";
                if (j != beta.size() - 1) cout << "| ";
            }
            cout << endl;

            cout << nonTerminal << "' -> ";
            for (size_t j = 0; j < alpha.size(); ++j) {


                cout << alpha[j] << nonTerminal << "' ";
                if (j != alpha.size() - 1) cout << "| ";
            }
            cout << "| ε" << endl;
        } else {
            // No left recursion
            cout << nonTerminal << " -> " << production << endl;
        }
    }

    return 0;
}
```

- **`if (!alpha.empty())`**: Checks if there are any rules with left recursion (i.e., `alpha` is not empty).
  - **`cout << nonTerminal << " -> ";`**: Prints the non-terminal and the new production rules.
  - **`for (size_t j = 0; j < beta.size(); ++j)`**: Loops through `beta` rules.
    - **`cout << beta[j] << nonTerminal << "' ";`**: Prints each rule from `beta` followed by `nonTerminal'`.
    - **`if (j != beta.size() - 1) cout << "| ";`**: Prints `|` between `beta` rules, except after the last rule.
  - **`cout << endl;`**: Moves to the next line after printing `beta` rules.
  - **`cout << nonTerminal << "' -> ";`**: Prints the new non-terminal for rules with left recursion.
  - **`for (size_t j = 0; j < alpha.size(); ++j)`**: Loops through `alpha` rules.
    - **`cout << alpha[j] << nonTerminal << "' ";`**: Prints each rule from `alpha` followed by `nonTerminal'`.
    - **`if (j != alpha.size() - 1) cout << "| ";`**: Prints `|` between `alpha` rules, except after the last rule.
  - **`cout << "| ε" << endl;`**: Adds `ε` (epsilon, representing an empty string) to the new non-terminal's production rules.
- **`else`**: If there is no left recursion (`alpha` is empty):
  - **`cout << nonTerminal << " -> " << production << endl;`**: Prints the original production as there is no left recursion.
- **`return 0;`**: Ends the `main` function and returns 0, indicating successful completion of the program.

### Summary

- **Initialization**: Sets up vectors to store productions and non-terminals.
- **Input**: Reads and processes the number of productions and their rules.
- **Processing**: Identifies and handles left recursion by splitting rules and transforming the grammar.
- **Output**: Prints the transformed grammar with left recursion removed or the original grammar if no transformation was needed.

This detailed breakdown explains the code's structure and logic for handling left recursion in context-free grammars.

*/